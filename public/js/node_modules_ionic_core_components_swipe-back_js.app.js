"use strict";
(self["webpackChunkhugo_interview_project"] = self["webpackChunkhugo_interview_project"] || []).push([["node_modules_ionic_core_components_swipe-back_js"],{

/***/ "./node_modules/@ionic/core/components/swipe-back.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ionic/core/components/swipe-back.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSwipeBackGesture": () => (/* binding */ createSwipeBackGesture)
/* harmony export */ });
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/@ionic/core/components/helpers.js");
/* harmony import */ var _dir_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dir.js */ "./node_modules/@ionic/core/components/dir.js");
/* harmony import */ var _index2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index2.js */ "./node_modules/@ionic/core/components/index2.js");
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */




const createSwipeBackGesture = (el, canStartHandler, onStartHandler, onMoveHandler, onEndHandler) => {
  const win = el.ownerDocument.defaultView;
  let rtl = (0,_dir_js__WEBPACK_IMPORTED_MODULE_0__.i)(el);
  /**
   * Determine if a gesture is near the edge
   * of the screen. If true, then the swipe
   * to go back gesture should proceed.
   */
  const isAtEdge = (detail) => {
    const threshold = 50;
    const { startX } = detail;
    if (rtl) {
      return startX >= win.innerWidth - threshold;
    }
    return startX <= threshold;
  };
  const getDeltaX = (detail) => {
    return rtl ? -detail.deltaX : detail.deltaX;
  };
  const getVelocityX = (detail) => {
    return rtl ? -detail.velocityX : detail.velocityX;
  };
  const canStart = (detail) => {
    /**
     * The user's locale can change mid-session,
     * so we need to check text direction at
     * the beginning of every gesture.
     */
    rtl = (0,_dir_js__WEBPACK_IMPORTED_MODULE_0__.i)(el);
    return isAtEdge(detail) && canStartHandler();
  };
  const onMove = (detail) => {
    // set the transition animation's progress
    const delta = getDeltaX(detail);
    const stepValue = delta / win.innerWidth;
    onMoveHandler(stepValue);
  };
  const onEnd = (detail) => {
    // the swipe back gesture has ended
    const delta = getDeltaX(detail);
    const width = win.innerWidth;
    const stepValue = delta / width;
    const velocity = getVelocityX(detail);
    const z = width / 2.0;
    const shouldComplete = velocity >= 0 && (velocity > 0.2 || delta > z);
    const missing = shouldComplete ? 1 - stepValue : stepValue;
    const missingDistance = missing * width;
    let realDur = 0;
    if (missingDistance > 5) {
      const dur = missingDistance / Math.abs(velocity);
      realDur = Math.min(dur, 540);
    }
    onEndHandler(shouldComplete, stepValue <= 0 ? 0.01 : (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.h)(0, stepValue, 0.9999), realDur);
  };
  return (0,_index2_js__WEBPACK_IMPORTED_MODULE_2__.createGesture)({
    el,
    gestureName: 'goback-swipe',
    gesturePriority: 40,
    threshold: 10,
    canStart,
    onStart: onStartHandler,
    onMove,
    onEnd,
  });
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfY29tcG9uZW50c19zd2lwZS1iYWNrX2pzLmFwcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQzBDO0FBQ0o7QUFDTTs7QUFFNUM7QUFDQTtBQUNBLFlBQVksMENBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMENBQUs7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDhDQUFLO0FBQzlEO0FBQ0EsU0FBUyx5REFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dhbWVjaGFuZ2VyLWludGVydmlldy1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvc3dpcGUtYmFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgaCBhcyBjbGFtcCB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzUlRMIH0gZnJvbSAnLi9kaXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlR2VzdHVyZSB9IGZyb20gJy4vaW5kZXgyLmpzJztcblxuY29uc3QgY3JlYXRlU3dpcGVCYWNrR2VzdHVyZSA9IChlbCwgY2FuU3RhcnRIYW5kbGVyLCBvblN0YXJ0SGFuZGxlciwgb25Nb3ZlSGFuZGxlciwgb25FbmRIYW5kbGVyKSA9PiB7XG4gIGNvbnN0IHdpbiA9IGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGxldCBydGwgPSBpc1JUTChlbCk7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSBnZXN0dXJlIGlzIG5lYXIgdGhlIGVkZ2VcbiAgICogb2YgdGhlIHNjcmVlbi4gSWYgdHJ1ZSwgdGhlbiB0aGUgc3dpcGVcbiAgICogdG8gZ28gYmFjayBnZXN0dXJlIHNob3VsZCBwcm9jZWVkLlxuICAgKi9cbiAgY29uc3QgaXNBdEVkZ2UgPSAoZGV0YWlsKSA9PiB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gNTA7XG4gICAgY29uc3QgeyBzdGFydFggfSA9IGRldGFpbDtcbiAgICBpZiAocnRsKSB7XG4gICAgICByZXR1cm4gc3RhcnRYID49IHdpbi5pbm5lcldpZHRoIC0gdGhyZXNob2xkO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnRYIDw9IHRocmVzaG9sZDtcbiAgfTtcbiAgY29uc3QgZ2V0RGVsdGFYID0gKGRldGFpbCkgPT4ge1xuICAgIHJldHVybiBydGwgPyAtZGV0YWlsLmRlbHRhWCA6IGRldGFpbC5kZWx0YVg7XG4gIH07XG4gIGNvbnN0IGdldFZlbG9jaXR5WCA9IChkZXRhaWwpID0+IHtcbiAgICByZXR1cm4gcnRsID8gLWRldGFpbC52ZWxvY2l0eVggOiBkZXRhaWwudmVsb2NpdHlYO1xuICB9O1xuICBjb25zdCBjYW5TdGFydCA9IChkZXRhaWwpID0+IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcidzIGxvY2FsZSBjYW4gY2hhbmdlIG1pZC1zZXNzaW9uLFxuICAgICAqIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGV4dCBkaXJlY3Rpb24gYXRcbiAgICAgKiB0aGUgYmVnaW5uaW5nIG9mIGV2ZXJ5IGdlc3R1cmUuXG4gICAgICovXG4gICAgcnRsID0gaXNSVEwoZWwpO1xuICAgIHJldHVybiBpc0F0RWRnZShkZXRhaWwpICYmIGNhblN0YXJ0SGFuZGxlcigpO1xuICB9O1xuICBjb25zdCBvbk1vdmUgPSAoZGV0YWlsKSA9PiB7XG4gICAgLy8gc2V0IHRoZSB0cmFuc2l0aW9uIGFuaW1hdGlvbidzIHByb2dyZXNzXG4gICAgY29uc3QgZGVsdGEgPSBnZXREZWx0YVgoZGV0YWlsKTtcbiAgICBjb25zdCBzdGVwVmFsdWUgPSBkZWx0YSAvIHdpbi5pbm5lcldpZHRoO1xuICAgIG9uTW92ZUhhbmRsZXIoc3RlcFZhbHVlKTtcbiAgfTtcbiAgY29uc3Qgb25FbmQgPSAoZGV0YWlsKSA9PiB7XG4gICAgLy8gdGhlIHN3aXBlIGJhY2sgZ2VzdHVyZSBoYXMgZW5kZWRcbiAgICBjb25zdCBkZWx0YSA9IGdldERlbHRhWChkZXRhaWwpO1xuICAgIGNvbnN0IHdpZHRoID0gd2luLmlubmVyV2lkdGg7XG4gICAgY29uc3Qgc3RlcFZhbHVlID0gZGVsdGEgLyB3aWR0aDtcbiAgICBjb25zdCB2ZWxvY2l0eSA9IGdldFZlbG9jaXR5WChkZXRhaWwpO1xuICAgIGNvbnN0IHogPSB3aWR0aCAvIDIuMDtcbiAgICBjb25zdCBzaG91bGRDb21wbGV0ZSA9IHZlbG9jaXR5ID49IDAgJiYgKHZlbG9jaXR5ID4gMC4yIHx8IGRlbHRhID4geik7XG4gICAgY29uc3QgbWlzc2luZyA9IHNob3VsZENvbXBsZXRlID8gMSAtIHN0ZXBWYWx1ZSA6IHN0ZXBWYWx1ZTtcbiAgICBjb25zdCBtaXNzaW5nRGlzdGFuY2UgPSBtaXNzaW5nICogd2lkdGg7XG4gICAgbGV0IHJlYWxEdXIgPSAwO1xuICAgIGlmIChtaXNzaW5nRGlzdGFuY2UgPiA1KSB7XG4gICAgICBjb25zdCBkdXIgPSBtaXNzaW5nRGlzdGFuY2UgLyBNYXRoLmFicyh2ZWxvY2l0eSk7XG4gICAgICByZWFsRHVyID0gTWF0aC5taW4oZHVyLCA1NDApO1xuICAgIH1cbiAgICBvbkVuZEhhbmRsZXIoc2hvdWxkQ29tcGxldGUsIHN0ZXBWYWx1ZSA8PSAwID8gMC4wMSA6IGNsYW1wKDAsIHN0ZXBWYWx1ZSwgMC45OTk5KSwgcmVhbER1cik7XG4gIH07XG4gIHJldHVybiBjcmVhdGVHZXN0dXJlKHtcbiAgICBlbCxcbiAgICBnZXN0dXJlTmFtZTogJ2dvYmFjay1zd2lwZScsXG4gICAgZ2VzdHVyZVByaW9yaXR5OiA0MCxcbiAgICB0aHJlc2hvbGQ6IDEwLFxuICAgIGNhblN0YXJ0LFxuICAgIG9uU3RhcnQ6IG9uU3RhcnRIYW5kbGVyLFxuICAgIG9uTW92ZSxcbiAgICBvbkVuZCxcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVTd2lwZUJhY2tHZXN0dXJlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=