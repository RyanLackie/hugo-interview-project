"use strict";
(self["webpackChunkhugo_interview_project"] = self["webpackChunkhugo_interview_project"] || []).push([["node_modules_ionic_core_components_index9_js"],{

/***/ "./node_modules/@ionic/core/components/index9.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ionic/core/components/index9.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startTapClick": () => (/* binding */ startTapClick)
/* harmony export */ });
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/@ionic/core/components/helpers.js");
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */


const startTapClick = (config) => {
  let lastTouch = -MOUSE_WAIT * 10;
  let lastActivated = 0;
  let activatableEle;
  let activeRipple;
  let activeDefer;
  const useRippleEffect = config.getBoolean('animated', true) && config.getBoolean('rippleEffect', true);
  const clearDefers = new WeakMap();
  // Touch Events
  const onTouchStart = (ev) => {
    lastTouch = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.u)(ev);
    pointerDown(ev);
  };
  const onTouchEnd = (ev) => {
    lastTouch = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.u)(ev);
    pointerUp(ev);
  };
  const onMouseDown = (ev) => {
    // Ignore right clicks
    if (ev.button === 2) {
      return;
    }
    const t = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.u)(ev) - MOUSE_WAIT;
    if (lastTouch < t) {
      pointerDown(ev);
    }
  };
  const onMouseUp = (ev) => {
    const t = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.u)(ev) - MOUSE_WAIT;
    if (lastTouch < t) {
      pointerUp(ev);
    }
  };
  const cancelActive = () => {
    if (activeDefer)
      clearTimeout(activeDefer);
    activeDefer = undefined;
    if (activatableEle) {
      removeActivated(false);
      activatableEle = undefined;
    }
  };
  const pointerDown = (ev) => {
    if (activatableEle) {
      return;
    }
    setActivatedElement(getActivatableTarget(ev), ev);
  };
  const pointerUp = (ev) => {
    setActivatedElement(undefined, ev);
  };
  const setActivatedElement = (el, ev) => {
    // do nothing
    if (el && el === activatableEle) {
      return;
    }
    if (activeDefer)
      clearTimeout(activeDefer);
    activeDefer = undefined;
    const { x, y } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.p)(ev);
    // deactivate selected
    if (activatableEle) {
      if (clearDefers.has(activatableEle)) {
        throw new Error('internal error');
      }
      if (!activatableEle.classList.contains(ACTIVATED)) {
        addActivated(activatableEle, x, y);
      }
      removeActivated(true);
    }
    // activate
    if (el) {
      const deferId = clearDefers.get(el);
      if (deferId) {
        clearTimeout(deferId);
        clearDefers.delete(el);
      }
      el.classList.remove(ACTIVATED);
      const callback = () => {
        addActivated(el, x, y);
        activeDefer = undefined;
      };
      if (isInstant(el)) {
        callback();
      }
      else {
        activeDefer = setTimeout(callback, ADD_ACTIVATED_DEFERS);
      }
    }
    activatableEle = el;
  };
  const addActivated = (el, x, y) => {
    lastActivated = Date.now();
    el.classList.add(ACTIVATED);
    if (!useRippleEffect)
      return;
    const rippleEffect = getRippleEffect(el);
    if (rippleEffect !== null) {
      removeRipple();
      activeRipple = rippleEffect.addRipple(x, y);
    }
  };
  const removeRipple = () => {
    if (activeRipple !== undefined) {
      activeRipple.then((remove) => remove());
      activeRipple = undefined;
    }
  };
  const removeActivated = (smooth) => {
    removeRipple();
    const active = activatableEle;
    if (!active) {
      return;
    }
    const time = CLEAR_STATE_DEFERS - Date.now() + lastActivated;
    if (smooth && time > 0 && !isInstant(active)) {
      const deferId = setTimeout(() => {
        active.classList.remove(ACTIVATED);
        clearDefers.delete(active);
      }, CLEAR_STATE_DEFERS);
      clearDefers.set(active, deferId);
    }
    else {
      active.classList.remove(ACTIVATED);
    }
  };
  const doc = document;
  doc.addEventListener('ionGestureCaptured', cancelActive);
  doc.addEventListener('touchstart', onTouchStart, true);
  doc.addEventListener('touchcancel', onTouchEnd, true);
  doc.addEventListener('touchend', onTouchEnd, true);
  /**
   * Tap click effects such as the ripple effect should
   * not happen when scrolling. For example, if a user scrolls
   * the page but also happens to do a touchstart on a button
   * as part of the scroll, the ripple effect should not
   * be dispatched. The ripple effect should only happen
   * if the button is activated and the page is not scrolling.
   *
   * pointercancel is dispatched on a gesture when scrolling
   * starts, so this lets us avoid having to listen for
   * ion-content's scroll events.
   */
  doc.addEventListener('pointercancel', cancelActive, true);
  doc.addEventListener('mousedown', onMouseDown, true);
  doc.addEventListener('mouseup', onMouseUp, true);
};
// TODO(FW-2832): type
const getActivatableTarget = (ev) => {
  if (ev.composedPath !== undefined) {
    /**
     * composedPath returns EventTarget[]. However,
     * objects other than Element can be targets too.
     * For example, AudioContext can be a target. In this
     * case, we know that the event is a UIEvent so we
     * can assume that the path will contain either Element
     * or ShadowRoot.
     */
    const path = ev.composedPath();
    for (let i = 0; i < path.length - 2; i++) {
      const el = path[i];
      if (!(el instanceof ShadowRoot) && el.classList.contains('ion-activatable')) {
        return el;
      }
    }
  }
  else {
    return ev.target.closest('.ion-activatable');
  }
};
const isInstant = (el) => {
  return el.classList.contains('ion-activatable-instant');
};
const getRippleEffect = (el) => {
  if (el.shadowRoot) {
    const ripple = el.shadowRoot.querySelector('ion-ripple-effect');
    if (ripple) {
      return ripple;
    }
  }
  return el.querySelector('ion-ripple-effect');
};
const ACTIVATED = 'ion-activated';
const ADD_ACTIVATED_DEFERS = 200;
const CLEAR_STATE_DEFERS = 200;
const MOUSE_WAIT = 2500;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfY29tcG9uZW50c19pbmRleDlfanMuYXBwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQzJEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBRztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxFQUFFLDhDQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2dhbWVjaGFuZ2VyLWludGVydmlldy1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW5kZXg5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyB1IGFzIG5vdywgcCBhcyBwb2ludGVyQ29vcmQgfSBmcm9tICcuL2hlbHBlcnMuanMnO1xuXG5jb25zdCBzdGFydFRhcENsaWNrID0gKGNvbmZpZykgPT4ge1xuICBsZXQgbGFzdFRvdWNoID0gLU1PVVNFX1dBSVQgKiAxMDtcbiAgbGV0IGxhc3RBY3RpdmF0ZWQgPSAwO1xuICBsZXQgYWN0aXZhdGFibGVFbGU7XG4gIGxldCBhY3RpdmVSaXBwbGU7XG4gIGxldCBhY3RpdmVEZWZlcjtcbiAgY29uc3QgdXNlUmlwcGxlRWZmZWN0ID0gY29uZmlnLmdldEJvb2xlYW4oJ2FuaW1hdGVkJywgdHJ1ZSkgJiYgY29uZmlnLmdldEJvb2xlYW4oJ3JpcHBsZUVmZmVjdCcsIHRydWUpO1xuICBjb25zdCBjbGVhckRlZmVycyA9IG5ldyBXZWFrTWFwKCk7XG4gIC8vIFRvdWNoIEV2ZW50c1xuICBjb25zdCBvblRvdWNoU3RhcnQgPSAoZXYpID0+IHtcbiAgICBsYXN0VG91Y2ggPSBub3coZXYpO1xuICAgIHBvaW50ZXJEb3duKGV2KTtcbiAgfTtcbiAgY29uc3Qgb25Ub3VjaEVuZCA9IChldikgPT4ge1xuICAgIGxhc3RUb3VjaCA9IG5vdyhldik7XG4gICAgcG9pbnRlclVwKGV2KTtcbiAgfTtcbiAgY29uc3Qgb25Nb3VzZURvd24gPSAoZXYpID0+IHtcbiAgICAvLyBJZ25vcmUgcmlnaHQgY2xpY2tzXG4gICAgaWYgKGV2LmJ1dHRvbiA9PT0gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ID0gbm93KGV2KSAtIE1PVVNFX1dBSVQ7XG4gICAgaWYgKGxhc3RUb3VjaCA8IHQpIHtcbiAgICAgIHBvaW50ZXJEb3duKGV2KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9uTW91c2VVcCA9IChldikgPT4ge1xuICAgIGNvbnN0IHQgPSBub3coZXYpIC0gTU9VU0VfV0FJVDtcbiAgICBpZiAobGFzdFRvdWNoIDwgdCkge1xuICAgICAgcG9pbnRlclVwKGV2KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNhbmNlbEFjdGl2ZSA9ICgpID0+IHtcbiAgICBpZiAoYWN0aXZlRGVmZXIpXG4gICAgICBjbGVhclRpbWVvdXQoYWN0aXZlRGVmZXIpO1xuICAgIGFjdGl2ZURlZmVyID0gdW5kZWZpbmVkO1xuICAgIGlmIChhY3RpdmF0YWJsZUVsZSkge1xuICAgICAgcmVtb3ZlQWN0aXZhdGVkKGZhbHNlKTtcbiAgICAgIGFjdGl2YXRhYmxlRWxlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICBpZiAoYWN0aXZhdGFibGVFbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0QWN0aXZhdGVkRWxlbWVudChnZXRBY3RpdmF0YWJsZVRhcmdldChldiksIGV2KTtcbiAgfTtcbiAgY29uc3QgcG9pbnRlclVwID0gKGV2KSA9PiB7XG4gICAgc2V0QWN0aXZhdGVkRWxlbWVudCh1bmRlZmluZWQsIGV2KTtcbiAgfTtcbiAgY29uc3Qgc2V0QWN0aXZhdGVkRWxlbWVudCA9IChlbCwgZXYpID0+IHtcbiAgICAvLyBkbyBub3RoaW5nXG4gICAgaWYgKGVsICYmIGVsID09PSBhY3RpdmF0YWJsZUVsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlRGVmZXIpXG4gICAgICBjbGVhclRpbWVvdXQoYWN0aXZlRGVmZXIpO1xuICAgIGFjdGl2ZURlZmVyID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnRlckNvb3JkKGV2KTtcbiAgICAvLyBkZWFjdGl2YXRlIHNlbGVjdGVkXG4gICAgaWYgKGFjdGl2YXRhYmxlRWxlKSB7XG4gICAgICBpZiAoY2xlYXJEZWZlcnMuaGFzKGFjdGl2YXRhYmxlRWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVybmFsIGVycm9yJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWFjdGl2YXRhYmxlRWxlLmNsYXNzTGlzdC5jb250YWlucyhBQ1RJVkFURUQpKSB7XG4gICAgICAgIGFkZEFjdGl2YXRlZChhY3RpdmF0YWJsZUVsZSwgeCwgeSk7XG4gICAgICB9XG4gICAgICByZW1vdmVBY3RpdmF0ZWQodHJ1ZSk7XG4gICAgfVxuICAgIC8vIGFjdGl2YXRlXG4gICAgaWYgKGVsKSB7XG4gICAgICBjb25zdCBkZWZlcklkID0gY2xlYXJEZWZlcnMuZ2V0KGVsKTtcbiAgICAgIGlmIChkZWZlcklkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkZWZlcklkKTtcbiAgICAgICAgY2xlYXJEZWZlcnMuZGVsZXRlKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoQUNUSVZBVEVEKTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBhZGRBY3RpdmF0ZWQoZWwsIHgsIHkpO1xuICAgICAgICBhY3RpdmVEZWZlciA9IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgICBpZiAoaXNJbnN0YW50KGVsKSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFjdGl2ZURlZmVyID0gc2V0VGltZW91dChjYWxsYmFjaywgQUREX0FDVElWQVRFRF9ERUZFUlMpO1xuICAgICAgfVxuICAgIH1cbiAgICBhY3RpdmF0YWJsZUVsZSA9IGVsO1xuICB9O1xuICBjb25zdCBhZGRBY3RpdmF0ZWQgPSAoZWwsIHgsIHkpID0+IHtcbiAgICBsYXN0QWN0aXZhdGVkID0gRGF0ZS5ub3coKTtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKEFDVElWQVRFRCk7XG4gICAgaWYgKCF1c2VSaXBwbGVFZmZlY3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcmlwcGxlRWZmZWN0ID0gZ2V0UmlwcGxlRWZmZWN0KGVsKTtcbiAgICBpZiAocmlwcGxlRWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICByZW1vdmVSaXBwbGUoKTtcbiAgICAgIGFjdGl2ZVJpcHBsZSA9IHJpcHBsZUVmZmVjdC5hZGRSaXBwbGUoeCwgeSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVSaXBwbGUgPSAoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZVJpcHBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhY3RpdmVSaXBwbGUudGhlbigocmVtb3ZlKSA9PiByZW1vdmUoKSk7XG4gICAgICBhY3RpdmVSaXBwbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVBY3RpdmF0ZWQgPSAoc21vb3RoKSA9PiB7XG4gICAgcmVtb3ZlUmlwcGxlKCk7XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZhdGFibGVFbGU7XG4gICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGltZSA9IENMRUFSX1NUQVRFX0RFRkVSUyAtIERhdGUubm93KCkgKyBsYXN0QWN0aXZhdGVkO1xuICAgIGlmIChzbW9vdGggJiYgdGltZSA+IDAgJiYgIWlzSW5zdGFudChhY3RpdmUpKSB7XG4gICAgICBjb25zdCBkZWZlcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGFjdGl2ZS5jbGFzc0xpc3QucmVtb3ZlKEFDVElWQVRFRCk7XG4gICAgICAgIGNsZWFyRGVmZXJzLmRlbGV0ZShhY3RpdmUpO1xuICAgICAgfSwgQ0xFQVJfU1RBVEVfREVGRVJTKTtcbiAgICAgIGNsZWFyRGVmZXJzLnNldChhY3RpdmUsIGRlZmVySWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFjdGl2ZS5jbGFzc0xpc3QucmVtb3ZlKEFDVElWQVRFRCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBkb2MgPSBkb2N1bWVudDtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbkdlc3R1cmVDYXB0dXJlZCcsIGNhbmNlbEFjdGl2ZSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCB0cnVlKTtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgb25Ub3VjaEVuZCwgdHJ1ZSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIHRydWUpO1xuICAvKipcbiAgICogVGFwIGNsaWNrIGVmZmVjdHMgc3VjaCBhcyB0aGUgcmlwcGxlIGVmZmVjdCBzaG91bGRcbiAgICogbm90IGhhcHBlbiB3aGVuIHNjcm9sbGluZy4gRm9yIGV4YW1wbGUsIGlmIGEgdXNlciBzY3JvbGxzXG4gICAqIHRoZSBwYWdlIGJ1dCBhbHNvIGhhcHBlbnMgdG8gZG8gYSB0b3VjaHN0YXJ0IG9uIGEgYnV0dG9uXG4gICAqIGFzIHBhcnQgb2YgdGhlIHNjcm9sbCwgdGhlIHJpcHBsZSBlZmZlY3Qgc2hvdWxkIG5vdFxuICAgKiBiZSBkaXNwYXRjaGVkLiBUaGUgcmlwcGxlIGVmZmVjdCBzaG91bGQgb25seSBoYXBwZW5cbiAgICogaWYgdGhlIGJ1dHRvbiBpcyBhY3RpdmF0ZWQgYW5kIHRoZSBwYWdlIGlzIG5vdCBzY3JvbGxpbmcuXG4gICAqXG4gICAqIHBvaW50ZXJjYW5jZWwgaXMgZGlzcGF0Y2hlZCBvbiBhIGdlc3R1cmUgd2hlbiBzY3JvbGxpbmdcbiAgICogc3RhcnRzLCBzbyB0aGlzIGxldHMgdXMgYXZvaWQgaGF2aW5nIHRvIGxpc3RlbiBmb3JcbiAgICogaW9uLWNvbnRlbnQncyBzY3JvbGwgZXZlbnRzLlxuICAgKi9cbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCBjYW5jZWxBY3RpdmUsIHRydWUpO1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24sIHRydWUpO1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCwgdHJ1ZSk7XG59O1xuLy8gVE9ETyhGVy0yODMyKTogdHlwZVxuY29uc3QgZ2V0QWN0aXZhdGFibGVUYXJnZXQgPSAoZXYpID0+IHtcbiAgaWYgKGV2LmNvbXBvc2VkUGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLyoqXG4gICAgICogY29tcG9zZWRQYXRoIHJldHVybnMgRXZlbnRUYXJnZXRbXS4gSG93ZXZlcixcbiAgICAgKiBvYmplY3RzIG90aGVyIHRoYW4gRWxlbWVudCBjYW4gYmUgdGFyZ2V0cyB0b28uXG4gICAgICogRm9yIGV4YW1wbGUsIEF1ZGlvQ29udGV4dCBjYW4gYmUgYSB0YXJnZXQuIEluIHRoaXNcbiAgICAgKiBjYXNlLCB3ZSBrbm93IHRoYXQgdGhlIGV2ZW50IGlzIGEgVUlFdmVudCBzbyB3ZVxuICAgICAqIGNhbiBhc3N1bWUgdGhhdCB0aGUgcGF0aCB3aWxsIGNvbnRhaW4gZWl0aGVyIEVsZW1lbnRcbiAgICAgKiBvciBTaGFkb3dSb290LlxuICAgICAqL1xuICAgIGNvbnN0IHBhdGggPSBldi5jb21wb3NlZFBhdGgoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICBjb25zdCBlbCA9IHBhdGhbaV07XG4gICAgICBpZiAoIShlbCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpICYmIGVsLmNsYXNzTGlzdC5jb250YWlucygnaW9uLWFjdGl2YXRhYmxlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZXYudGFyZ2V0LmNsb3Nlc3QoJy5pb24tYWN0aXZhdGFibGUnKTtcbiAgfVxufTtcbmNvbnN0IGlzSW5zdGFudCA9IChlbCkgPT4ge1xuICByZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdpb24tYWN0aXZhdGFibGUtaW5zdGFudCcpO1xufTtcbmNvbnN0IGdldFJpcHBsZUVmZmVjdCA9IChlbCkgPT4ge1xuICBpZiAoZWwuc2hhZG93Um9vdCkge1xuICAgIGNvbnN0IHJpcHBsZSA9IGVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignaW9uLXJpcHBsZS1lZmZlY3QnKTtcbiAgICBpZiAocmlwcGxlKSB7XG4gICAgICByZXR1cm4gcmlwcGxlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcignaW9uLXJpcHBsZS1lZmZlY3QnKTtcbn07XG5jb25zdCBBQ1RJVkFURUQgPSAnaW9uLWFjdGl2YXRlZCc7XG5jb25zdCBBRERfQUNUSVZBVEVEX0RFRkVSUyA9IDIwMDtcbmNvbnN0IENMRUFSX1NUQVRFX0RFRkVSUyA9IDIwMDtcbmNvbnN0IE1PVVNFX1dBSVQgPSAyNTAwO1xuXG5leHBvcnQgeyBzdGFydFRhcENsaWNrIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=